h1. Sidekick

Sidekick is a command line tool to automatically trigger certain tasks following certain events, as defined in a @.sidekick@ file in your project folder.

You would typically run it in the background while coding, to automatize things like restarting development servers on file changes, recompiling assets, continously running tests or periodically running commands.


h2. Basic usage

Install with @gem install sidekick@ and invoke it using the @sidekick@ shell command in your project folder. You should have a @.sidekick@ file in it. Here is a sample:

<pre>
<code lang='ruby'>

# restarts passenger on file changes and
# notifies via growl or libnotify
watch '**/*.rb' do |paths|
  restart_passenger
  notify 'Are you tired of being notified yet?'
end

# shows a new fortune in terminal every 10 seconds
every(10) do
  sh 'fortune'
end

</code>
</pre>

The @watch@ and @every@ commands are are triggers, while @notify@, @sh@, and @restart_passenger@ are helper methods.

h3. Currently available triggers:

|@watch@|run on file changes|
|@every(duration)@|run every @duration@ seconds|

h3. Currently available helpers:

|@sh@|run shell command, showing output, like in rake|
|@log@|log events to screen. cleaner than puts.|
|@notify@|notify user via growl, libnotify etc|
|@running?(platform)@|os can be one of @[:linux, :darwin, :other]@|
|@load_gem?(name)@|tries to load gem, true if success. otherwise false. informs user that more functions are available if they make it available|
|@restart_passenger@|restart passenger based environments by touching tmp/restart.txt|

h2. Writing extensions

h3. Writing new helpers

To add more helpers, simply add methods to @Sidekick::Helpers@, like this:

<pre>
<code lang='ruby'>
  module Sidekick::Helpers
    def make_pickle
      PickeFactory.manufacture!
    end
  end
</code>
</pre>

When adding a group of methods it may be cleaner to use a separate module under @Sidekick::Helpers@, and then include it.


h3. Writing new triggers

To add new triggers, you have two options: block or class interface. Blocks are best for simple stuff, while classes are good for more complex code. This is how you set up a new trigger using a block:

<pre>
<code lang='ruby'>

register :every do |callback, duration|
  timeshare(duration) do
    callback.call
  end
end

</code>
</pre>

This is the internal implementation of the @every@ function mentioned earlier. The @timeshare@ method is provided by Sidekick to all extensions, and will call the supplied block each @duration@ seconds. This is also useful for polling something without blocking or forking.

Triggers can also be written as a class interface. Here is an example of the above, translated as a class:

<pre>
<code lang='ruby'>

class Sidekick::Triggers::Every

  def initialize(callback, duration)
    @callback = callback
    @duration = duration
  end

  def poll
    @callback.call
  end

  def poll_freq
    @duration
  end
end

Sidekick::Triggers.register_class(:watch, Watch)

</code>
</pre>

Here, the optional @poll@ method functions like the callback block in the previous example. The @poll_freq@ method is also optional, and determines the frequency in seconds with which to call @poll@. Finally, notice the last statement, which registers the class.

h2. Final lines...

The main code chunk is just under 100 lines including documentation, excluding the default triggers and helpers. Why not read it..?

You can keep your extensions in the @.sidekick@ file itself, or package in a separate gem, or ask me to merge them into the main repository.

I got a bit of inspiration from the somewhat similar project "Guard":http://github.com/guard/guard


h3. Copyright

Copyright (c) 2010 Jostein Berre Eliassen. See LICENSE for details.
